{"ast":null,"code":"/*!\n* tabbable 5.2.1\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\nvar candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable=\"false\"])', 'details>summary:first-of-type', 'details'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nvar isContentEditable = function isContentEditable(node) {\n  return node.contentEditable === 'true';\n};\n\nvar getTabindex = function getTabindex(node) {\n  var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  } // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n\n\n  if (isContentEditable(node)) {\n    return 0;\n  } // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n\n\n  if ((node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\n\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\n\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\n\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n\n  var radioScope = node.form || node.ownerDocument;\n\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n\n  var radioSet;\n\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nvar isHidden = function isHidden(node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    var _node$getBoundingClie = node.getBoundingClientRect(),\n        width = _node$getBoundingClie.width,\n        height = _node$getBoundingClie.height;\n\n    return width === 0 && height === 0;\n  }\n\n  return false;\n}; // form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\n\n\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (isInput(node) || node.tagName === 'SELECT' || node.tagName === 'TEXTAREA' || node.tagName === 'BUTTON') {\n    var parentNode = node.parentElement;\n\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> as an immediate child of the disabled\n        //  <fieldset>: if the node is in that legend, it'll be enabled even\n        //  though the fieldset is disabled; otherwise, the node is in a\n        //  secondary/subsequent legend, or somewhere else within the fieldset\n        //  (however deep nested) and it'll be disabled\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n\n          if (child.tagName === 'LEGEND') {\n            if (child.contains(node)) {\n              return false;\n            } // the node isn't in the first legend (in doc order), so no matter\n            //  where it is now, it'll be disabled\n\n\n            return true;\n          }\n        } // the node isn't in a legend, so no matter where it is now, it'll be disabled\n\n\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  } // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n\n\n  return false;\n};\n\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled || isHiddenInput(node) || isHidden(node, options.displayCheck) || // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (!isNodeMatchingSelectorFocusable(options, node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {\n    return false;\n  }\n\n  return true;\n};\n\nvar tabbable = function tabbable(el, options) {\n  options = options || {};\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  candidates.forEach(function (candidate, i) {\n    var candidateTabindex = getTabindex(candidate);\n\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate\n      });\n    }\n  });\n  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {\n    return a.node;\n  }).concat(regularTabbables);\n  return tabbableNodes;\n};\n\nvar focusable = function focusable(el, options) {\n  options = options || {};\n  var candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  return candidates;\n};\n\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\n\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n\n  if (!node) {\n    throw new Error('No node provided');\n  }\n\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, isFocusable, isTabbable, tabbable };","map":{"version":3,"mappings":"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","names":["candidateSelectors","candidateSelector","join","matches","Element","prototype","msMatchesSelector","webkitMatchesSelector","getCandidates","el","includeContainer","filter","candidates","Array","slice","apply","querySelectorAll","call","unshift","isContentEditable","node","contentEditable","getTabindex","tabindexAttr","parseInt","getAttribute","isNaN","nodeName","tabIndex","sortOrderedTabbables","a","b","documentOrder","isInput","tagName","isHiddenInput","type","isDetailsWithSummary","r","children","some","child","getCheckedRadio","nodes","form","i","length","checked","isTabbableRadio","name","radioScope","ownerDocument","queryRadios","radioSet","window","CSS","escape","err","console","error","message","isRadio","isNonTabbableRadio","isHidden","displayCheck","getComputedStyle","visibility","isDirectSummary","nodeUnderDetails","parentElement","display","getBoundingClientRect","width","height","isDisabledFromFieldset","parentNode","disabled","item","contains","isNodeMatchingSelectorFocusable","options","isNodeMatchingSelectorTabbable","tabbable","regularTabbables","orderedTabbables","bind","forEach","candidate","candidateTabindex","push","tabbableNodes","sort","map","concat","focusable","isTabbable","Error","focusableCandidateSelector","isFocusable"],"sources":["/Users/tendainyandoro/Documents/School/interaction-checker/node_modules/tabbable/src/index.js"],"sourcesContent":["const candidateSelectors = [\n  'input',\n  'select',\n  'textarea',\n  'a[href]',\n  'button',\n  '[tabindex]',\n  'audio[controls]',\n  'video[controls]',\n  '[contenteditable]:not([contenteditable=\"false\"])',\n  'details>summary:first-of-type',\n  'details',\n];\nconst candidateSelector = /* #__PURE__ */ candidateSelectors.join(',');\n\nconst matches =\n  typeof Element === 'undefined'\n    ? function () {}\n    : Element.prototype.matches ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.webkitMatchesSelector;\n\nconst getCandidates = function (el, includeContainer, filter) {\n  let candidates = Array.prototype.slice.apply(\n    el.querySelectorAll(candidateSelector)\n  );\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\nconst isContentEditable = function (node) {\n  return node.contentEditable === 'true';\n};\n\nconst getTabindex = function (node) {\n  const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);\n\n  if (!isNaN(tabindexAttr)) {\n    return tabindexAttr;\n  }\n\n  // Browsers do not return `tabIndex` correctly for contentEditable nodes;\n  // so if they don't have a tabindex attribute specifically set, assume it's 0.\n  if (isContentEditable(node)) {\n    return 0;\n  }\n\n  // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n  //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n  //  yet they are still part of the regular tab order; in FF, they get a default\n  //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n  //  order, consider their tab index to be 0.\n  if (\n    (node.nodeName === 'AUDIO' ||\n      node.nodeName === 'VIDEO' ||\n      node.nodeName === 'DETAILS') &&\n    node.getAttribute('tabindex') === null\n  ) {\n    return 0;\n  }\n\n  return node.tabIndex;\n};\n\nconst sortOrderedTabbables = function (a, b) {\n  return a.tabIndex === b.tabIndex\n    ? a.documentOrder - b.documentOrder\n    : a.tabIndex - b.tabIndex;\n};\n\nconst isInput = function (node) {\n  return node.tagName === 'INPUT';\n};\n\nconst isHiddenInput = function (node) {\n  return isInput(node) && node.type === 'hidden';\n};\n\nconst isDetailsWithSummary = function (node) {\n  const r =\n    node.tagName === 'DETAILS' &&\n    Array.prototype.slice\n      .apply(node.children)\n      .some((child) => child.tagName === 'SUMMARY');\n  return r;\n};\n\nconst getCheckedRadio = function (nodes, form) {\n  for (let i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\n\nconst isTabbableRadio = function (node) {\n  if (!node.name) {\n    return true;\n  }\n  const radioScope = node.form || node.ownerDocument;\n\n  const queryRadios = function (name) {\n    return radioScope.querySelectorAll(\n      'input[type=\"radio\"][name=\"' + name + '\"]'\n    );\n  };\n\n  let radioSet;\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.CSS !== 'undefined' &&\n    typeof window.CSS.escape === 'function'\n  ) {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(\n        'Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s',\n        err.message\n      );\n      return false;\n    }\n  }\n\n  const checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\n\nconst isRadio = function (node) {\n  return isInput(node) && node.type === 'radio';\n};\n\nconst isNonTabbableRadio = function (node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\nconst isHidden = function (node, displayCheck) {\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n\n  const isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  const nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full') {\n    while (node) {\n      if (getComputedStyle(node).display === 'none') {\n        return true;\n      }\n      node = node.parentElement;\n    }\n  } else if (displayCheck === 'non-zero-area') {\n    const { width, height } = node.getBoundingClientRect();\n    return width === 0 && height === 0;\n  }\n\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nconst isDisabledFromFieldset = function (node) {\n  if (\n    isInput(node) ||\n    node.tagName === 'SELECT' ||\n    node.tagName === 'TEXTAREA' ||\n    node.tagName === 'BUTTON'\n  ) {\n    let parentNode = node.parentElement;\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> as an immediate child of the disabled\n        //  <fieldset>: if the node is in that legend, it'll be enabled even\n        //  though the fieldset is disabled; otherwise, the node is in a\n        //  secondary/subsequent legend, or somewhere else within the fieldset\n        //  (however deep nested) and it'll be disabled\n        for (let i = 0; i < parentNode.children.length; i++) {\n          const child = parentNode.children.item(i);\n          if (child.tagName === 'LEGEND') {\n            if (child.contains(node)) {\n              return false;\n            }\n\n            // the node isn't in the first legend (in doc order), so no matter\n            //  where it is now, it'll be disabled\n            return true;\n          }\n        }\n\n        // the node isn't in a legend, so no matter where it is now, it'll be disabled\n        return true;\n      }\n\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\n\nconst isNodeMatchingSelectorFocusable = function (options, node) {\n  if (\n    node.disabled ||\n    isHiddenInput(node) ||\n    isHidden(node, options.displayCheck) ||\n    // For a details element with a summary, the summary element gets the focus\n    isDetailsWithSummary(node) ||\n    isDisabledFromFieldset(node)\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst isNodeMatchingSelectorTabbable = function (options, node) {\n  if (\n    !isNodeMatchingSelectorFocusable(options, node) ||\n    isNonTabbableRadio(node) ||\n    getTabindex(node) < 0\n  ) {\n    return false;\n  }\n  return true;\n};\n\nconst tabbable = function (el, options) {\n  options = options || {};\n\n  const regularTabbables = [];\n  const orderedTabbables = [];\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorTabbable.bind(null, options)\n  );\n\n  candidates.forEach(function (candidate, i) {\n    const candidateTabindex = getTabindex(candidate);\n    if (candidateTabindex === 0) {\n      regularTabbables.push(candidate);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        node: candidate,\n      });\n    }\n  });\n\n  const tabbableNodes = orderedTabbables\n    .sort(sortOrderedTabbables)\n    .map((a) => a.node)\n    .concat(regularTabbables);\n\n  return tabbableNodes;\n};\n\nconst focusable = function (el, options) {\n  options = options || {};\n\n  const candidates = getCandidates(\n    el,\n    options.includeContainer,\n    isNodeMatchingSelectorFocusable.bind(null, options)\n  );\n\n  return candidates;\n};\n\nconst isTabbable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\n\nconst focusableCandidateSelector = /* #__PURE__ */ candidateSelectors\n  .concat('iframe')\n  .join(',');\n\nconst isFocusable = function (node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { tabbable, focusable, isTabbable, isFocusable };\n"]},"metadata":{},"sourceType":"module"}